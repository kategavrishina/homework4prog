import re
# работают только со строками
# re.search('re'(предмет поиска),s(строка))
if re.search('re',s):    --- проверка на наличие
    print(s)
# . - любой символ: .a.a (lala, fada) КРОМЕ ПЕРЕНОСА СТРОКИ
# квантификатор - сколько раз предыдущий символ будет повторяться:
#       b? - может содержаться 0 или 1 раз
#       с+ - 1 и больше
#       d* - 0 и более
# [] - символьные классы([бвгдж] - один из символов = 'б'; 'г'; 'д')
#       [бвгдж]+ - от 1 и более (бж, гг, д, вввввгв)
#       [а-я], [а-яА-Я] кроме буквы ё! --> [а-яА-ЯёЁ]
#       также возможно [а-яА-Я,.+] - квантификаторы теряют свое значение
# экранирование! (вне квадр. скобок): \+ \? \. \*
# чтобы просто был дефис - [-абв], [аб\-д], [абв-]
# все цифры [0-9], или \d (но есть нюансы)
# а|о - а или о, (а|о) - группировка символов
# ^ - [^абвгде] - любые, кроме этих
# не жадный поиск - <.+?>

r = re.search('...', s)
if r:
    string = r.group()
    print(string)
# '\. ([А-Я][а-я]+)'
    string = r.group(1)
# если много групп:
    string1 = r.group(1)
    string2 = r.group(2)
            ...
# ^ - начало данных, строки; $ - конец
# '([a-z]+)@\1\.ru' (напр. admin@admin.ru)
# \\1 или r'\1'; r'\n\' - последний  слэш перед кавычками не экранируется
re.search(regexp, string)
re.findall(regexp, string) --> список
re.sub(regexp, repl, string)
# plain_text = re.sub('<.+?>', '', html) - удаление тегов
rg = ['regexp1', 'regexp2'..]
for regexp in rg:
    text = re.sub(regexp, '', text)
